//
// Created by jantonio on 25/06/19.
//

#define SERIALCHRONOMETER_AJAX_JSON_C
#include <stdio.h>
#include <string.h>

#include "main.h"
#include "sc_config.h"
#include "sc_tools.h"
#include "debug.h"
#include "ajax_json.h"
#include "tiny-json.h"

#define MSG_LEN 256

static char * process_eventData(configuration *config,char const * datastr, int *eventID, time_t *timestamp) {
    char *data=calloc(strlen(datastr),sizeof(char));
    memcpy(data,datastr,strlen(datastr));
    json_t jdata[128];
    json_t const* rdata = json_create( data, jdata, sizeof jdata / sizeof *jdata );
    char const* typestr = json_getPropertyValue( rdata, "Type" );
    char const* tsstr = json_getPropertyValue( rdata, "TimeStamp" );
    if (tsstr) *timestamp=atoll(tsstr);
    char const* sname = json_getPropertyValue( rdata, "SessionName" );
    char const* valuestr = json_getPropertyValue( rdata, "Value" );
    char const* startstr = json_getPropertyValue( rdata, "start" ); // lowercase
    debug(DBG_INFO,"Event %d Data:%s Type:%s Value:%s",*eventID,datastr,typestr,valuestr);
    if (sname && (strcmp(sname,getSessionName(config))==0)) {
        // IMPORTANT: ignore any event generated by me to avoid infinite loops
        debug(DBG_ERROR,"Ignore my own generated events");
        return NULL;
    }
    char *result=calloc(MSG_LEN,sizeof(char));
    if (!result) {
        debug(DBG_ERROR,"process_eventData::calloc() cannot reserve space for SerialAPI command");
        return NULL;
    }
    if ( strcmp(typestr,"null")==0) { // null event
        // no action
    }
    else if ( strcmp(typestr,"init")==0) { // connect to session
        // guardamos en informacion de estado datos de prueba y jornada
        // NOTA: esto deberia hacerse en main_mgr, pero habría que mandar un "reset" y puede interferir,
        // con lo que dado que los datos de manga,tanda, etc solo se usan aquí, lo ajustamos desde aqui
        char const *pru=json_getPropertyValue( rdata, "Pru" );
        char const *jor=json_getPropertyValue( rdata, "Jor" );
        config->status.prueba=atoi(pru);
        config->status.jornada=atoi(jor);
        // other status values set to zero
        config->status.manga=0;
        config->status.tanda=0;
        config->status.numero=0;
        config->status.dorsal=0;
        config->status.perro=0;
        config->status.equipo=0;
        config->status.faults=0;
        config->status.refusals=0;
        config->status.eliminated=0;
        config->status.notpresent=0;
    }
    else if ( strcmp(typestr,"login")==0) { // user login
        // no action
    }
    else if ( strcmp(typestr,"open")==0) { // tanda selection
        // guardamos en informacion de estado datos de manga y tanda

        // NOTA: esto deberia hacerse en main_mgr, pero habría que mandar un "reset" y puede interferir,
        // con lo que dado que los datos de manga,tanda, etc solo se usan aquí, lo ajustamos desde aqui
        char const *mng=json_getPropertyValue( rdata, "Mng" );
        char const *tnd=json_getPropertyValue( rdata, "Tnd" );
        config->status.manga=atoi(mng);
        config->status.tanda=atoi(tnd);
        config->status.numero=0;
        config->status.dorsal=0;
        config->status.perro=0;
        config->status.equipo=0;
        config->status.faults=0;
        config->status.refusals=0;
        config->status.eliminated=0;
        config->status.notpresent=0;
    }
    else if ( strcmp(typestr,"close")==0) { // tanda exit
        // no action
    }
    else if ( strcmp(typestr,"salida")==0) { // 15 seconds countdown
        snprintf(result,MSG_LEN,"down 15\n");
    }
    else if ( strcmp(typestr,"start")==0) { // manual chrono start. Value= timestamp
        snprintf(result,MSG_LEN,"start %s\n",valuestr);
    }
    else if ( strcmp(typestr,"stop")==0) { // manual chrono stop. Value=timestamp
        snprintf(result,MSG_LEN,"stop %s\n",valuestr);
    }
    else if ( strcmp(typestr,"crono_start")==0) { // electronic chrono start Value=timestamp
        snprintf(result,MSG_LEN,"start %s\n",valuestr);
    }
    else if ( strcmp(typestr,"crono_int")==0) { // electronic chrono intermediate time Value=timestamp
        time_t int_time=atoll(valuestr);
        snprintf(result,MSG_LEN,"int %s\n",valuestr);
    }
    else if ( strcmp(typestr,"crono_stop")==0) {  // electronic chrono start Value=timestamp
        snprintf(result,MSG_LEN,"stop %s\n",valuestr);
    }
    else if ( strcmp(typestr,"crono_rec")==0) { // course walk. start=seconds
        time_t seconds= (startstr)?atoll(startstr):0L;
        snprintf(result,MSG_LEN,"walk %lu\n",seconds);
    }
    else if ( strcmp(typestr,"crono_dat")==0) { // dog data FRE
        char const *flt=json_getPropertyValue( rdata, "Flt" );
        char const *toc=json_getPropertyValue( rdata, "Toc" );
        char const *reh=json_getPropertyValue( rdata, "Reh" );
        char const *eli=json_getPropertyValue( rdata, "Eli" );
        char const *npr=json_getPropertyValue( rdata, "NPr" );
        int f=(strcmp(flt,"-1")==0)?config->status.faults:atoi(flt);
        int t=(strcmp(toc,"-1")==0)?0:atoi(toc);
        int r=(strcmp(reh,"-1")==0)?config->status.refusals:atoi(reh);
        int e=(strcmp(eli,"-1")==0)?config->status.eliminated:atoi(eli);
        int n=(strcmp(npr,"-1")==0)?config->status.notpresent:atoi(npr); // not present is not used but required
        snprintf(result,MSG_LEN,"data %d:%d:%d\n",f+t,r,e);
    }
    else if ( strcmp(typestr,"crono_restart")==0) { // swicth crono from manual to electronic
        // no action: previous manual start remains active
    }
    else if ( strcmp(typestr,"crono_reset")==0) { // reset crono and dog data
        snprintf(result,MSG_LEN,"reset\n");
    }
    else if ( strcmp(typestr,"crono_error")==0) { // sensor error
        snprintf(result,MSG_LEN,"fail\n");
    }
    else if ( strcmp(typestr,"crono_ready")==0) { // sensor recovery
        snprintf(result,MSG_LEN,"ok\n");
    }
    else if ( strcmp(typestr,"llamada")==0) { // Call dog to enter in ring
        // actualizamos informacion de estado con datos del perro
        char const *drs=json_getPropertyValue( rdata, "Drs" );
        char const *dog=json_getPropertyValue( rdata, "Dog" );
        char const *eqp=json_getPropertyValue( rdata, "Eqp" );
        config->status.dorsal=atoi(drs);
        config->status.perro=atoi(dog);
        config->status.equipo=atoi(eqp);

        // guardamos información recibida sobre estado del perro
        char const *flt=json_getPropertyValue( rdata, "Flt" );
        char const *toc=json_getPropertyValue( rdata, "Toc" );
        char const *reh=json_getPropertyValue( rdata, "Reh" );
        char const *eli=json_getPropertyValue( rdata, "Eli" );
        char const *npr=json_getPropertyValue( rdata, "NPr" );
        if (strcmp("-1",flt)!=0) config->status.faults=atoi(flt);
        if (strcmp("-1",toc)!=0) config->status.faults += atoi(toc);
        if (strcmp("-1",reh)!=0) config->status.refusals=atoi(reh);
        if (strcmp("-1",eli)!=0) config->status.eliminated=atoi(eli);
        if (strcmp("-1",flt)!=0) config->status.notpresent=atoi(npr);

        // generamos SerialAPI msg con el numero de turno del perro
        char const *num=json_getPropertyValue( rdata, "Numero" );
        snprintf(result,MSG_LEN,"turn %s\n",num);
    }
    else if ( strcmp(typestr,"datos")==0) { // manual dog data
        char const *flt=json_getPropertyValue( rdata, "Flt" );
        char const *toc=json_getPropertyValue( rdata, "Toc" );
        char const *reh=json_getPropertyValue( rdata, "Reh" );
        char const *eli=json_getPropertyValue( rdata, "Eli" );
        char const *npr=json_getPropertyValue( rdata, "NPr" );
        int f=(strcmp(flt,"-1")==0)?config->status.faults:atoi(flt);
        int t=(strcmp(toc,"-1")==0)?0:atoi(toc);
        int r=(strcmp(reh,"-1")==0)?config->status.refusals:atoi(reh);
        int e=(strcmp(eli,"-1")==0)?config->status.eliminated:atoi(eli);
        int n=(strcmp(npr,"-1")==0)?config->status.notpresent:atoi(npr); // not present is not used in this program
        snprintf(result,MSG_LEN,"data %d:%d:%d\n",f+t,r,e);
    }
    else if ( strcmp(typestr,"aceptar")==0) { // validate dog data
        // no action
    }
    else if ( strcmp(typestr,"cancelar")==0) { // reset dog data
        // no action
    }
    else if ( strcmp(typestr,"info")==0) { // informational event. no action required
        debug(DBG_NOTICE,"ajaxmgr: received event info '%s'",valuestr);
    }
    else if ( strcmp(typestr,"user")==0) { // user defined event
        // no action
    }
    else if ( strcmp(typestr,"command")==0) { // miscelaneous commands Value
        // only allowed command is Oper:7: Value: seconds:msg
        char const* operstr = json_getPropertyValue( rdata, "Oper" );
        if (strcmp("8",operstr)==0) {
            char *secs=strdup(valuestr);
            char *msg=strchr(secs,':');
            if (msg) *msg++='\0';
            snprintf(result,MSG_LEN,"msg %s %s\n",secs,msg);
            free(secs);
        }
    }
    else if ( strcmp(typestr,"camera")==0) { // switch camera sources for session
        // no action
    }
    else if ( strcmp(typestr,"reconfig")==0) { // server reconfiguration
        // no action
    }
    else { // unknown event. notify and continue
        debug(DBG_ERROR,"ajaxmgr: received unknown event type '%s'",typestr);
    }
    if (strcmp(result,"")==0) {
        free(result);
        result=NULL;
    }
    return result;
}

/**
 * parse a selectring request and extract session for choosen ring
 * @param config configuration parameters
 * @param json_str string to parse from selectring ajax response
 * @param json_str string length ( to avoid re-evaluate strlen )
 * @return session id for selected ring, -1 on error/notfound
 */
int parse_select(configuration *config, char *json_str, size_t json_len){
    char ring[16];
    snprintf(ring,16,"Ring %d",config->ring);

    json_t mem[1024];
    // get root
    json_t const* root = json_create( json_str, mem, sizeof mem / sizeof *mem );
    if ( !root ) {
        debug(DBG_ERROR,"Error parse_select::json_create()");
        return -1;
    }
    // get rows array
    json_t const* rows = json_getProperty( root, "rows" );
    if ( !rows || JSON_ARRAY != json_getType( rows ) ) {
        debug(DBG_ERROR,"parse_select::json_getProperty(rows)");
        return -1;
    }
    // iterate over rows to find session id for provided ring
    json_t const* session;
    for( session = json_getChild( rows ); session != 0; session = json_getSibling( session ) ) {
        if ( JSON_OBJ == json_getType( session ) ) {
            char const* ringNumber = json_getPropertyValue( session, "Nombre" );
            if (strcmp(ringNumber,ring)!=0) continue;
            char const* sesidstr=json_getPropertyValue( session, "ID" );
            debug(DBG_INFO,"Found Sesion id %s for %s",sesidstr,ring);
            return atoi(sesidstr);
        }
    }
    // arriving here means session "Ring X" not found
    debug(DBG_ERROR,"Session '%s' not found in selectring() ajax response",ring);
    return -1;
}

/**
 * Parse a connect request and extract last init eventID and timestamp for choosen ring
 * Also fill working data info
 * @param config configuration parameters
 * @param json_str string to parse
 * @param json_len string length
 * @return last "init" event id for selected ring, 0 on no events; -1 on error
 */
int parse_connect(configuration *config, char *json_str,size_t json_len) {
    json_t mem[1024];
    // get root
    json_t const* root = json_create( json_str, mem, sizeof mem / sizeof *mem );
    if ( !root ) {
        debug(DBG_ERROR,"Error parse_connect::json_create()");
        return -1;
    }

    // check for session active
    char const* total=json_getPropertyValue( root, "total" );
    if (! total) {
        debug(DBG_ERROR,"parse_connect::getPropertyValue(total): invalid received json response %s",json_str);
        return -1;
    }
    if (strcmp("0",total)==0) {
        debug(DBG_NOTICE,"parse_connect::getPropertyValue(total): no 'init' event registered (yet) on ring %d",config->ring);
        return 0;
    }
    // obtenemos el ultimo event id por el metodo guarro de recorrer la lista y quedarnos con el ultimo evento
    // get rows array
    json_t const* rows = json_getProperty( root, "rows" );
    if ( !rows || JSON_ARRAY != json_getType( rows ) ) {
        debug(DBG_ERROR,"parse_connect::json_getProperty(rows)");
        return -1;
    }
    // iterate over rows to find session id for provided ring
    int eventID=0;
    json_t const* event;
    for( event = json_getChild( rows ); event != 0; event = json_getSibling( event ) ) {
        if ( JSON_OBJ == json_getType( event ) ) {
            char const* eventstr = json_getPropertyValue( event, "ID" );
            debug(DBG_INFO,"Found 'init' event id %s for ring %d",eventstr,config->ring);
            eventID=atoi(eventstr);
        }
    }
    return eventID;
}

/**
 * parse getEvents request
 *
 * process each received event for requested session/ring
 * Generate serial_chrono API request according received data
 * extract last init eventID and timestamp for choosen ring
 * @param config configuration parameters
 * @param json_str string to parse
 * @param json_len string length
 * @param evtid pointer to store last event id
 * @param timestamp pointer to store last event timestamp
 * @return list of serial chrono API commands to be executed. null on error, or empty array if no data to send
 */
char **parse_events(configuration *config, char *json_str,size_t json_len, int *evtid, time_t *timestamp) {
    // dirty way to count tokens:
    size_t count=0;
    for (char *pt=json_str;*pt;pt++) if (*pt==':') count++;
    json_t mem[count];
    // get root token
    json_t const* root = json_create( json_str, mem, sizeof mem / sizeof *mem );
    if ( !root ) {
        debug(DBG_ERROR,"Error parse_events::json_create()");
        return NULL;
    }

    // check for session active
    char const* total=json_getPropertyValue( root, "total" );
    if (! total) {
        debug(DBG_ERROR,"parse_events::getPropertyValue(total): invalid received json response %s",json_str);
        return NULL;
    }
    if (strcmp("0",total)==0) {
        debug(DBG_NOTICE,"parse_events::getPropertyValue('total'): no events received since last call on ring %d",config->ring);
    }
    // get rows array
    json_t const* rows = json_getProperty( root, "rows" );
    if ( !rows || JSON_ARRAY != json_getType( rows ) ) {
        debug(DBG_ERROR,"parse_events::json_getProperty('rows')");
        return NULL;
    }
    // creamos un array de comandos de longitud total+1
    char **result= calloc(1+atoi(total),sizeof(char*));
    if (!result) {
        debug(DBG_ERROR,"parse_events::calloc(numrows): cannot allocate space for response");
        return NULL;
    }
    int evt_count=0;
    // obtenemos el ultimo event id por el metodo guarro de recorrer la lista y quedarnos con el ultimo evento
    for( json_t const *event = json_getChild( rows ); event != 0; event = json_getSibling( event ) ) {
        if ( JSON_OBJ == json_getType( event ) ) {
            // cogemos el event ID
            char const* eventstr = json_getPropertyValue( event, "ID" );
            debug(DBG_INFO,"Parsing event id %s on ring %d",eventstr,config->ring);
            *evtid=atoi(eventstr);
            // analizamos ahora el campo "Data" para extraer Type,Value y TimeStamp
            char const *data = json_getPropertyValue( event, "Data" );
            if ( !data ) {
                // PENDING: study if exists events with no Data and how to handle them
                debug(DBG_ERROR,"parse_events::json_getPropertyValue('event/Data') cannot get Data for eventid: %s",eventstr);
                continue;
            }
            // field "Data is a string representing a json object
            result[evt_count]=process_eventData(config,data,evtid,timestamp);
            if (result[evt_count]!=NULL) evt_count++;
        }
    }
    return result;
}
